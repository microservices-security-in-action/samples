import { NgZone, OnDestroy } from '@angular/core';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { Observable, Subject, Subscription } from 'rxjs';
import { ValidationHandler, ValidationParams } from './token-validation/validation-handler';
import { UrlHelperService } from './url-helper.service';
import { OAuthEvent, OAuthSuccessEvent } from './events';
import { OAuthLogger, OAuthStorage, LoginOptions, ParsedIdToken, OidcDiscoveryDoc, TokenResponse, UserInfo } from './types';
import { AuthConfig } from './auth.config';
import { HashHandler } from './token-validation/hash-handler';
/**
 * Service for logging in and logging out with
 * OIDC and OAuth2. Supports implicit flow and
 * password flow.
 */
import * as ɵngcc0 from '@angular/core';
export declare class OAuthService extends AuthConfig implements OnDestroy {
    protected ngZone: NgZone;
    protected http: HttpClient;
    protected config: AuthConfig;
    protected urlHelper: UrlHelperService;
    protected logger: OAuthLogger;
    protected crypto: HashHandler;
    /**
     * The ValidationHandler used to validate received
     * id_tokens.
     */
    tokenValidationHandler: ValidationHandler;
    /**
     * @internal
     * Deprecated:  use property events instead
     */
    discoveryDocumentLoaded: boolean;
    /**
     * @internal
     * Deprecated:  use property events instead
     */
    discoveryDocumentLoaded$: Observable<OidcDiscoveryDoc>;
    /**
     * Informs about events, like token_received or token_expires.
     * See the string enum EventType for a full list of event types.
     */
    events: Observable<OAuthEvent>;
    /**
     * The received (passed around) state, when logging
     * in with implicit flow.
     */
    state?: string;
    protected eventsSubject: Subject<OAuthEvent>;
    protected discoveryDocumentLoadedSubject: Subject<OidcDiscoveryDoc>;
    protected silentRefreshPostMessageEventListener: EventListener;
    protected grantTypesSupported: Array<string>;
    protected _storage: OAuthStorage;
    protected accessTokenTimeoutSubscription: Subscription;
    protected idTokenTimeoutSubscription: Subscription;
    protected tokenReceivedSubscription: Subscription;
    protected sessionCheckEventListener: EventListener;
    protected jwksUri: string;
    protected sessionCheckTimer: any;
    protected silentRefreshSubject: string;
    protected inImplicitFlow: boolean;
    constructor(ngZone: NgZone, http: HttpClient, storage: OAuthStorage, tokenValidationHandler: ValidationHandler, config: AuthConfig, urlHelper: UrlHelperService, logger: OAuthLogger, crypto: HashHandler);
    /**
     * Use this method to configure the service
     * @param config the configuration
     */
    configure(config: AuthConfig): void;
    protected configChanged(): void;
    restartSessionChecksIfStillLoggedIn(): void;
    protected restartRefreshTimerIfStillLoggedIn(): void;
    protected setupSessionCheck(): void;
    /**
     * Will setup up silent refreshing for when the token is
     * about to expire. When the user is logged out via this.logOut method, the
     * silent refreshing will pause and not refresh the tokens until the user is
     * logged back in via receiving a new token.
     * @param params Additional parameter to pass
     * @param listenTo Setup automatic refresh of a specific token type
     */
    setupAutomaticSilentRefresh(params?: object, listenTo?: 'access_token' | 'id_token' | 'any', noPrompt?: boolean): void;
    protected refreshInternal(params: any, noPrompt: any): Promise<TokenResponse | OAuthEvent>;
    /**
     * Convenience method that first calls `loadDiscoveryDocument(...)` and
     * directly chains using the `then(...)` part of the promise to call
     * the `tryLogin(...)` method.
     *
     * @param options LoginOptions to pass through to `tryLogin(...)`
     */
    loadDiscoveryDocumentAndTryLogin(options?: LoginOptions): Promise<boolean>;
    /**
     * Convenience method that first calls `loadDiscoveryDocumentAndTryLogin(...)`
     * and if then chains to `initLoginFlow()`, but only if there is no valid
     * IdToken or no valid AccessToken.
     *
     * @param options LoginOptions to pass through to `tryLogin(...)`
     */
    loadDiscoveryDocumentAndLogin(options?: LoginOptions & {
        state?: string;
    }): Promise<boolean>;
    protected debug(...args: any[]): void;
    protected validateUrlFromDiscoveryDocument(url: string): string[];
    protected validateUrlForHttps(url: string): boolean;
    protected assertUrlNotNullAndCorrectProtocol(url: string | undefined, description: string): void;
    protected validateUrlAgainstIssuer(url: string): boolean;
    protected setupRefreshTimer(): void;
    protected setupExpirationTimers(): void;
    protected setupAccessTokenTimer(): void;
    protected setupIdTokenTimer(): void;
    protected clearAccessTokenTimer(): void;
    protected clearIdTokenTimer(): void;
    protected calcTimeout(storedAt: number, expiration: number): number;
    /**
     * DEPRECATED. Use a provider for OAuthStorage instead:
     *
     * { provide: OAuthStorage, useFactory: oAuthStorageFactory }
     * export function oAuthStorageFactory(): OAuthStorage { return localStorage; }
     * Sets a custom storage used to store the received
     * tokens on client side. By default, the browser's
     * sessionStorage is used.
     * @ignore
     *
     * @param storage
     */
    setStorage(storage: OAuthStorage): void;
    /**
     * Loads the discovery document to configure most
     * properties of this service. The url of the discovery
     * document is infered from the issuer's url according
     * to the OpenId Connect spec. To use another url you
     * can pass it to to optional parameter fullUrl.
     *
     * @param fullUrl
     */
    loadDiscoveryDocument(fullUrl?: string): Promise<OAuthSuccessEvent>;
    protected loadJwks(): Promise<object>;
    protected validateDiscoveryDocument(doc: OidcDiscoveryDoc): boolean;
    /**
     * Uses password flow to exchange userName and password for an
     * access_token. After receiving the access_token, this method
     * uses it to query the userinfo endpoint in order to get information
     * about the user in question.
     *
     * When using this, make sure that the property oidc is set to false.
     * Otherwise stricter validations take place that make this operation
     * fail.
     *
     * @param userName
     * @param password
     * @param headers Optional additional http-headers.
     */
    fetchTokenUsingPasswordFlowAndLoadUserProfile(userName: string, password: string, headers?: HttpHeaders): Promise<UserInfo>;
    /**
     * Loads the user profile by accessing the user info endpoint defined by OpenId Connect.
     *
     * When using this with OAuth2 password flow, make sure that the property oidc is set to false.
     * Otherwise stricter validations take place that make this operation fail.
     */
    loadUserProfile(): Promise<UserInfo>;
    /**
     * Uses password flow to exchange userName and password for an access_token.
     * @param userName
     * @param password
     * @param headers Optional additional http-headers.
     */
    fetchTokenUsingPasswordFlow(userName: string, password: string, headers?: HttpHeaders): Promise<TokenResponse>;
    /**
     * Refreshes the token using a refresh_token.
     * This does not work for implicit flow, b/c
     * there is no refresh_token in this flow.
     * A solution for this is provided by the
     * method silentRefresh.
     */
    refreshToken(): Promise<TokenResponse>;
    protected removeSilentRefreshEventListener(): void;
    protected setupSilentRefreshEventListener(): void;
    /**
     * Performs a silent refresh for implicit flow.
     * Use this method to get new tokens when/before
     * the existing tokens expire.
     */
    silentRefresh(params?: object, noPrompt?: boolean): Promise<OAuthEvent>;
    /**
     * This method exists for backwards compatibility.
     * {@link OAuthService#initLoginFlowInPopup} handles both code
     * and implicit flows.
     */
    initImplicitFlowInPopup(options?: {
        height?: number;
        width?: number;
    }): Promise<{}>;
    initLoginFlowInPopup(options?: {
        height?: number;
        width?: number;
    }): Promise<{}>;
    protected calculatePopupFeatures(options: {
        height?: number;
        width?: number;
    }): string;
    protected processMessageEventMessage(e: MessageEvent): string;
    protected canPerformSessionCheck(): boolean;
    protected setupSessionCheckEventListener(): void;
    protected handleSessionUnchanged(): void;
    protected handleSessionChange(): void;
    protected waitForSilentRefreshAfterSessionChange(): void;
    protected handleSessionError(): void;
    protected removeSessionCheckEventListener(): void;
    protected initSessionCheck(): void;
    protected startSessionCheckTimer(): void;
    protected stopSessionCheckTimer(): void;
    protected checkSession(): void;
    protected createLoginUrl(state?: string, loginHint?: string, customRedirectUri?: string, noPrompt?: boolean, params?: object): Promise<string>;
    initImplicitFlowInternal(additionalState?: string, params?: string | object): void;
    /**
     * Starts the implicit flow and redirects to user to
     * the auth servers' login url.
     *
     * @param additionalState Optional state that is passed around.
     *  You'll find this state in the property `state` after `tryLogin` logged in the user.
     * @param params Hash with additional parameter. If it is a string, it is used for the
     *               parameter loginHint (for the sake of compatibility with former versions)
     */
    initImplicitFlow(additionalState?: string, params?: string | object): void;
    /**
     * Reset current implicit flow
     *
     * @description This method allows resetting the current implict flow in order to be initialized again.
     */
    resetImplicitFlow(): void;
    protected callOnTokenReceivedIfExists(options: LoginOptions): void;
    protected storeAccessTokenResponse(accessToken: string, refreshToken: string, expiresIn: number, grantedScopes: String): void;
    /**
     * Delegates to tryLoginImplicitFlow for the sake of competability
     * @param options Optional options.
     */
    tryLogin(options?: LoginOptions): Promise<boolean>;
    private parseQueryString;
    tryLoginCodeFlow(options?: LoginOptions): Promise<void>;
    /**
    * Retrieve the returned auth code from the redirect uri that has been called.
    * If required also check hash, as we could use hash location strategy.
    */
    private getCodePartsFromUrl;
    /**
     * Get token using an intermediate code. Works for the Authorization Code flow.
     */
    private getTokenFromCode;
    private fetchAndProcessToken;
    /**
     * Checks whether there are tokens in the hash fragment
     * as a result of the implicit flow. These tokens are
     * parsed, validated and used to sign the user in to the
     * current client.
     *
     * @param options Optional options.
     */
    tryLoginImplicitFlow(options?: LoginOptions): Promise<boolean>;
    private parseState;
    protected validateNonce(nonceInState: string): boolean;
    protected storeIdToken(idToken: ParsedIdToken): void;
    protected storeSessionState(sessionState: string): void;
    protected getSessionState(): string;
    protected handleLoginError(options: LoginOptions, parts: object): void;
    /**
     * @ignore
     */
    processIdToken(idToken: string, accessToken: string, skipNonceCheck?: boolean): Promise<ParsedIdToken>;
    /**
     * Returns the received claims about the user.
     */
    getIdentityClaims(): object;
    /**
     * Returns the granted scopes from the server.
     */
    getGrantedScopes(): object;
    /**
     * Returns the current id_token.
     */
    getIdToken(): string;
    protected padBase64(base64data: any): string;
    /**
     * Returns the current access_token.
     */
    getAccessToken(): string;
    getRefreshToken(): string;
    /**
     * Returns the expiration date of the access_token
     * as milliseconds since 1970.
     */
    getAccessTokenExpiration(): number;
    protected getAccessTokenStoredAt(): number;
    protected getIdTokenStoredAt(): number;
    /**
     * Returns the expiration date of the id_token
     * as milliseconds since 1970.
     */
    getIdTokenExpiration(): number;
    /**
     * Checkes, whether there is a valid access_token.
     */
    hasValidAccessToken(): boolean;
    /**
     * Checks whether there is a valid id_token.
     */
    hasValidIdToken(): boolean;
    /**
     * Returns the auth-header that can be used
     * to transmit the access_token to a service
     */
    authorizationHeader(): string;
    /**
     * Removes all tokens and logs the user out.
     * If a logout url is configured, the user is
     * redirected to it.
     * @param noRedirectToLogoutUrl
     */
    logOut(noRedirectToLogoutUrl?: boolean): void;
    /**
     * @ignore
     */
    createAndSaveNonce(): Promise<string>;
    /**
     * @ignore
     */
    ngOnDestroy(): void;
    protected createNonce(): Promise<string>;
    protected checkAtHash(params: ValidationParams): Promise<boolean>;
    protected checkSignature(params: ValidationParams): Promise<any>;
    /**
     * Start the implicit flow or the code flow,
     * depending on your configuration.
     */
    initLoginFlow(additionalState?: string, params?: {}): void;
    /**
     * Starts the authorization code flow and redirects to user to
     * the auth servers login url.
     */
    initCodeFlow(additionalState?: string, params?: {}): void;
    private initCodeFlowInternal;
    protected createChallangeVerifierPairForPKCE(): Promise<[string, string]>;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<OAuthService>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<OAuthService>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2F1dGgtc2VydmljZS5kLnRzIiwic291cmNlcyI6WyJvYXV0aC1zZXJ2aWNlLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztBQWNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbVVBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmdab25lLCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgSHR0cENsaWVudCwgSHR0cEhlYWRlcnMgfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YmplY3QsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBWYWxpZGF0aW9uSGFuZGxlciwgVmFsaWRhdGlvblBhcmFtcyB9IGZyb20gJy4vdG9rZW4tdmFsaWRhdGlvbi92YWxpZGF0aW9uLWhhbmRsZXInO1xyXG5pbXBvcnQgeyBVcmxIZWxwZXJTZXJ2aWNlIH0gZnJvbSAnLi91cmwtaGVscGVyLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBPQXV0aEV2ZW50LCBPQXV0aFN1Y2Nlc3NFdmVudCB9IGZyb20gJy4vZXZlbnRzJztcclxuaW1wb3J0IHsgT0F1dGhMb2dnZXIsIE9BdXRoU3RvcmFnZSwgTG9naW5PcHRpb25zLCBQYXJzZWRJZFRva2VuLCBPaWRjRGlzY292ZXJ5RG9jLCBUb2tlblJlc3BvbnNlLCBVc2VySW5mbyB9IGZyb20gJy4vdHlwZXMnO1xyXG5pbXBvcnQgeyBBdXRoQ29uZmlnIH0gZnJvbSAnLi9hdXRoLmNvbmZpZyc7XHJcbmltcG9ydCB7IEhhc2hIYW5kbGVyIH0gZnJvbSAnLi90b2tlbi12YWxpZGF0aW9uL2hhc2gtaGFuZGxlcic7XHJcbi8qKlxyXG4gKiBTZXJ2aWNlIGZvciBsb2dnaW5nIGluIGFuZCBsb2dnaW5nIG91dCB3aXRoXHJcbiAqIE9JREMgYW5kIE9BdXRoMi4gU3VwcG9ydHMgaW1wbGljaXQgZmxvdyBhbmRcclxuICogcGFzc3dvcmQgZmxvdy5cclxuICovXHJcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE9BdXRoU2VydmljZSBleHRlbmRzIEF1dGhDb25maWcgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xyXG4gICAgcHJvdGVjdGVkIG5nWm9uZTogTmdab25lO1xyXG4gICAgcHJvdGVjdGVkIGh0dHA6IEh0dHBDbGllbnQ7XHJcbiAgICBwcm90ZWN0ZWQgY29uZmlnOiBBdXRoQ29uZmlnO1xyXG4gICAgcHJvdGVjdGVkIHVybEhlbHBlcjogVXJsSGVscGVyU2VydmljZTtcclxuICAgIHByb3RlY3RlZCBsb2dnZXI6IE9BdXRoTG9nZ2VyO1xyXG4gICAgcHJvdGVjdGVkIGNyeXB0bzogSGFzaEhhbmRsZXI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBWYWxpZGF0aW9uSGFuZGxlciB1c2VkIHRvIHZhbGlkYXRlIHJlY2VpdmVkXHJcbiAgICAgKiBpZF90b2tlbnMuXHJcbiAgICAgKi9cclxuICAgIHRva2VuVmFsaWRhdGlvbkhhbmRsZXI6IFZhbGlkYXRpb25IYW5kbGVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqIERlcHJlY2F0ZWQ6ICB1c2UgcHJvcGVydHkgZXZlbnRzIGluc3RlYWRcclxuICAgICAqL1xyXG4gICAgZGlzY292ZXJ5RG9jdW1lbnRMb2FkZWQ6IGJvb2xlYW47XHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICogRGVwcmVjYXRlZDogIHVzZSBwcm9wZXJ0eSBldmVudHMgaW5zdGVhZFxyXG4gICAgICovXHJcbiAgICBkaXNjb3ZlcnlEb2N1bWVudExvYWRlZCQ6IE9ic2VydmFibGU8T2lkY0Rpc2NvdmVyeURvYz47XHJcbiAgICAvKipcclxuICAgICAqIEluZm9ybXMgYWJvdXQgZXZlbnRzLCBsaWtlIHRva2VuX3JlY2VpdmVkIG9yIHRva2VuX2V4cGlyZXMuXHJcbiAgICAgKiBTZWUgdGhlIHN0cmluZyBlbnVtIEV2ZW50VHlwZSBmb3IgYSBmdWxsIGxpc3Qgb2YgZXZlbnQgdHlwZXMuXHJcbiAgICAgKi9cclxuICAgIGV2ZW50czogT2JzZXJ2YWJsZTxPQXV0aEV2ZW50PjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHJlY2VpdmVkIChwYXNzZWQgYXJvdW5kKSBzdGF0ZSwgd2hlbiBsb2dnaW5nXHJcbiAgICAgKiBpbiB3aXRoIGltcGxpY2l0IGZsb3cuXHJcbiAgICAgKi9cclxuICAgIHN0YXRlPzogc3RyaW5nO1xyXG4gICAgcHJvdGVjdGVkIGV2ZW50c1N1YmplY3Q6IFN1YmplY3Q8T0F1dGhFdmVudD47XHJcbiAgICBwcm90ZWN0ZWQgZGlzY292ZXJ5RG9jdW1lbnRMb2FkZWRTdWJqZWN0OiBTdWJqZWN0PE9pZGNEaXNjb3ZlcnlEb2M+O1xyXG4gICAgcHJvdGVjdGVkIHNpbGVudFJlZnJlc2hQb3N0TWVzc2FnZUV2ZW50TGlzdGVuZXI6IEV2ZW50TGlzdGVuZXI7XHJcbiAgICBwcm90ZWN0ZWQgZ3JhbnRUeXBlc1N1cHBvcnRlZDogQXJyYXk8c3RyaW5nPjtcclxuICAgIHByb3RlY3RlZCBfc3RvcmFnZTogT0F1dGhTdG9yYWdlO1xyXG4gICAgcHJvdGVjdGVkIGFjY2Vzc1Rva2VuVGltZW91dFN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xyXG4gICAgcHJvdGVjdGVkIGlkVG9rZW5UaW1lb3V0U3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XHJcbiAgICBwcm90ZWN0ZWQgdG9rZW5SZWNlaXZlZFN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xyXG4gICAgcHJvdGVjdGVkIHNlc3Npb25DaGVja0V2ZW50TGlzdGVuZXI6IEV2ZW50TGlzdGVuZXI7XHJcbiAgICBwcm90ZWN0ZWQgandrc1VyaTogc3RyaW5nO1xyXG4gICAgcHJvdGVjdGVkIHNlc3Npb25DaGVja1RpbWVyOiBhbnk7XHJcbiAgICBwcm90ZWN0ZWQgc2lsZW50UmVmcmVzaFN1YmplY3Q6IHN0cmluZztcclxuICAgIHByb3RlY3RlZCBpbkltcGxpY2l0RmxvdzogYm9vbGVhbjtcclxuICAgIGNvbnN0cnVjdG9yKG5nWm9uZTogTmdab25lLCBodHRwOiBIdHRwQ2xpZW50LCBzdG9yYWdlOiBPQXV0aFN0b3JhZ2UsIHRva2VuVmFsaWRhdGlvbkhhbmRsZXI6IFZhbGlkYXRpb25IYW5kbGVyLCBjb25maWc6IEF1dGhDb25maWcsIHVybEhlbHBlcjogVXJsSGVscGVyU2VydmljZSwgbG9nZ2VyOiBPQXV0aExvZ2dlciwgY3J5cHRvOiBIYXNoSGFuZGxlcik7XHJcbiAgICAvKipcclxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBjb25maWd1cmUgdGhlIHNlcnZpY2VcclxuICAgICAqIEBwYXJhbSBjb25maWcgdGhlIGNvbmZpZ3VyYXRpb25cclxuICAgICAqL1xyXG4gICAgY29uZmlndXJlKGNvbmZpZzogQXV0aENvbmZpZyk6IHZvaWQ7XHJcbiAgICBwcm90ZWN0ZWQgY29uZmlnQ2hhbmdlZCgpOiB2b2lkO1xyXG4gICAgcmVzdGFydFNlc3Npb25DaGVja3NJZlN0aWxsTG9nZ2VkSW4oKTogdm9pZDtcclxuICAgIHByb3RlY3RlZCByZXN0YXJ0UmVmcmVzaFRpbWVySWZTdGlsbExvZ2dlZEluKCk6IHZvaWQ7XHJcbiAgICBwcm90ZWN0ZWQgc2V0dXBTZXNzaW9uQ2hlY2soKTogdm9pZDtcclxuICAgIC8qKlxyXG4gICAgICogV2lsbCBzZXR1cCB1cCBzaWxlbnQgcmVmcmVzaGluZyBmb3Igd2hlbiB0aGUgdG9rZW4gaXNcclxuICAgICAqIGFib3V0IHRvIGV4cGlyZS4gV2hlbiB0aGUgdXNlciBpcyBsb2dnZWQgb3V0IHZpYSB0aGlzLmxvZ091dCBtZXRob2QsIHRoZVxyXG4gICAgICogc2lsZW50IHJlZnJlc2hpbmcgd2lsbCBwYXVzZSBhbmQgbm90IHJlZnJlc2ggdGhlIHRva2VucyB1bnRpbCB0aGUgdXNlciBpc1xyXG4gICAgICogbG9nZ2VkIGJhY2sgaW4gdmlhIHJlY2VpdmluZyBhIG5ldyB0b2tlbi5cclxuICAgICAqIEBwYXJhbSBwYXJhbXMgQWRkaXRpb25hbCBwYXJhbWV0ZXIgdG8gcGFzc1xyXG4gICAgICogQHBhcmFtIGxpc3RlblRvIFNldHVwIGF1dG9tYXRpYyByZWZyZXNoIG9mIGEgc3BlY2lmaWMgdG9rZW4gdHlwZVxyXG4gICAgICovXHJcbiAgICBzZXR1cEF1dG9tYXRpY1NpbGVudFJlZnJlc2gocGFyYW1zPzogb2JqZWN0LCBsaXN0ZW5Ubz86ICdhY2Nlc3NfdG9rZW4nIHwgJ2lkX3Rva2VuJyB8ICdhbnknLCBub1Byb21wdD86IGJvb2xlYW4pOiB2b2lkO1xyXG4gICAgcHJvdGVjdGVkIHJlZnJlc2hJbnRlcm5hbChwYXJhbXM6IGFueSwgbm9Qcm9tcHQ6IGFueSk6IFByb21pc2U8VG9rZW5SZXNwb25zZSB8IE9BdXRoRXZlbnQ+O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCBmaXJzdCBjYWxscyBgbG9hZERpc2NvdmVyeURvY3VtZW50KC4uLilgIGFuZFxyXG4gICAgICogZGlyZWN0bHkgY2hhaW5zIHVzaW5nIHRoZSBgdGhlbiguLi4pYCBwYXJ0IG9mIHRoZSBwcm9taXNlIHRvIGNhbGxcclxuICAgICAqIHRoZSBgdHJ5TG9naW4oLi4uKWAgbWV0aG9kLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIExvZ2luT3B0aW9ucyB0byBwYXNzIHRocm91Z2ggdG8gYHRyeUxvZ2luKC4uLilgXHJcbiAgICAgKi9cclxuICAgIGxvYWREaXNjb3ZlcnlEb2N1bWVudEFuZFRyeUxvZ2luKG9wdGlvbnM/OiBMb2dpbk9wdGlvbnMpOiBQcm9taXNlPGJvb2xlYW4+O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCBmaXJzdCBjYWxscyBgbG9hZERpc2NvdmVyeURvY3VtZW50QW5kVHJ5TG9naW4oLi4uKWBcclxuICAgICAqIGFuZCBpZiB0aGVuIGNoYWlucyB0byBgaW5pdExvZ2luRmxvdygpYCwgYnV0IG9ubHkgaWYgdGhlcmUgaXMgbm8gdmFsaWRcclxuICAgICAqIElkVG9rZW4gb3Igbm8gdmFsaWQgQWNjZXNzVG9rZW4uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgTG9naW5PcHRpb25zIHRvIHBhc3MgdGhyb3VnaCB0byBgdHJ5TG9naW4oLi4uKWBcclxuICAgICAqL1xyXG4gICAgbG9hZERpc2NvdmVyeURvY3VtZW50QW5kTG9naW4ob3B0aW9ucz86IExvZ2luT3B0aW9ucyAmIHtcclxuICAgICAgICBzdGF0ZT86IHN0cmluZztcclxuICAgIH0pOiBQcm9taXNlPGJvb2xlYW4+O1xyXG4gICAgcHJvdGVjdGVkIGRlYnVnKC4uLmFyZ3M6IGFueVtdKTogdm9pZDtcclxuICAgIHByb3RlY3RlZCB2YWxpZGF0ZVVybEZyb21EaXNjb3ZlcnlEb2N1bWVudCh1cmw6IHN0cmluZyk6IHN0cmluZ1tdO1xyXG4gICAgcHJvdGVjdGVkIHZhbGlkYXRlVXJsRm9ySHR0cHModXJsOiBzdHJpbmcpOiBib29sZWFuO1xyXG4gICAgcHJvdGVjdGVkIGFzc2VydFVybE5vdE51bGxBbmRDb3JyZWN0UHJvdG9jb2wodXJsOiBzdHJpbmcgfCB1bmRlZmluZWQsIGRlc2NyaXB0aW9uOiBzdHJpbmcpOiB2b2lkO1xyXG4gICAgcHJvdGVjdGVkIHZhbGlkYXRlVXJsQWdhaW5zdElzc3Vlcih1cmw6IHN0cmluZyk6IGJvb2xlYW47XHJcbiAgICBwcm90ZWN0ZWQgc2V0dXBSZWZyZXNoVGltZXIoKTogdm9pZDtcclxuICAgIHByb3RlY3RlZCBzZXR1cEV4cGlyYXRpb25UaW1lcnMoKTogdm9pZDtcclxuICAgIHByb3RlY3RlZCBzZXR1cEFjY2Vzc1Rva2VuVGltZXIoKTogdm9pZDtcclxuICAgIHByb3RlY3RlZCBzZXR1cElkVG9rZW5UaW1lcigpOiB2b2lkO1xyXG4gICAgcHJvdGVjdGVkIGNsZWFyQWNjZXNzVG9rZW5UaW1lcigpOiB2b2lkO1xyXG4gICAgcHJvdGVjdGVkIGNsZWFySWRUb2tlblRpbWVyKCk6IHZvaWQ7XHJcbiAgICBwcm90ZWN0ZWQgY2FsY1RpbWVvdXQoc3RvcmVkQXQ6IG51bWJlciwgZXhwaXJhdGlvbjogbnVtYmVyKTogbnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBERVBSRUNBVEVELiBVc2UgYSBwcm92aWRlciBmb3IgT0F1dGhTdG9yYWdlIGluc3RlYWQ6XHJcbiAgICAgKlxyXG4gICAgICogeyBwcm92aWRlOiBPQXV0aFN0b3JhZ2UsIHVzZUZhY3Rvcnk6IG9BdXRoU3RvcmFnZUZhY3RvcnkgfVxyXG4gICAgICogZXhwb3J0IGZ1bmN0aW9uIG9BdXRoU3RvcmFnZUZhY3RvcnkoKTogT0F1dGhTdG9yYWdlIHsgcmV0dXJuIGxvY2FsU3RvcmFnZTsgfVxyXG4gICAgICogU2V0cyBhIGN1c3RvbSBzdG9yYWdlIHVzZWQgdG8gc3RvcmUgdGhlIHJlY2VpdmVkXHJcbiAgICAgKiB0b2tlbnMgb24gY2xpZW50IHNpZGUuIEJ5IGRlZmF1bHQsIHRoZSBicm93c2VyJ3NcclxuICAgICAqIHNlc3Npb25TdG9yYWdlIGlzIHVzZWQuXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHN0b3JhZ2VcclxuICAgICAqL1xyXG4gICAgc2V0U3RvcmFnZShzdG9yYWdlOiBPQXV0aFN0b3JhZ2UpOiB2b2lkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyB0aGUgZGlzY292ZXJ5IGRvY3VtZW50IHRvIGNvbmZpZ3VyZSBtb3N0XHJcbiAgICAgKiBwcm9wZXJ0aWVzIG9mIHRoaXMgc2VydmljZS4gVGhlIHVybCBvZiB0aGUgZGlzY292ZXJ5XHJcbiAgICAgKiBkb2N1bWVudCBpcyBpbmZlcmVkIGZyb20gdGhlIGlzc3VlcidzIHVybCBhY2NvcmRpbmdcclxuICAgICAqIHRvIHRoZSBPcGVuSWQgQ29ubmVjdCBzcGVjLiBUbyB1c2UgYW5vdGhlciB1cmwgeW91XHJcbiAgICAgKiBjYW4gcGFzcyBpdCB0byB0byBvcHRpb25hbCBwYXJhbWV0ZXIgZnVsbFVybC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZnVsbFVybFxyXG4gICAgICovXHJcbiAgICBsb2FkRGlzY292ZXJ5RG9jdW1lbnQoZnVsbFVybD86IHN0cmluZyk6IFByb21pc2U8T0F1dGhTdWNjZXNzRXZlbnQ+O1xyXG4gICAgcHJvdGVjdGVkIGxvYWRKd2tzKCk6IFByb21pc2U8b2JqZWN0PjtcclxuICAgIHByb3RlY3RlZCB2YWxpZGF0ZURpc2NvdmVyeURvY3VtZW50KGRvYzogT2lkY0Rpc2NvdmVyeURvYyk6IGJvb2xlYW47XHJcbiAgICAvKipcclxuICAgICAqIFVzZXMgcGFzc3dvcmQgZmxvdyB0byBleGNoYW5nZSB1c2VyTmFtZSBhbmQgcGFzc3dvcmQgZm9yIGFuXHJcbiAgICAgKiBhY2Nlc3NfdG9rZW4uIEFmdGVyIHJlY2VpdmluZyB0aGUgYWNjZXNzX3Rva2VuLCB0aGlzIG1ldGhvZFxyXG4gICAgICogdXNlcyBpdCB0byBxdWVyeSB0aGUgdXNlcmluZm8gZW5kcG9pbnQgaW4gb3JkZXIgdG8gZ2V0IGluZm9ybWF0aW9uXHJcbiAgICAgKiBhYm91dCB0aGUgdXNlciBpbiBxdWVzdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBXaGVuIHVzaW5nIHRoaXMsIG1ha2Ugc3VyZSB0aGF0IHRoZSBwcm9wZXJ0eSBvaWRjIGlzIHNldCB0byBmYWxzZS5cclxuICAgICAqIE90aGVyd2lzZSBzdHJpY3RlciB2YWxpZGF0aW9ucyB0YWtlIHBsYWNlIHRoYXQgbWFrZSB0aGlzIG9wZXJhdGlvblxyXG4gICAgICogZmFpbC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdXNlck5hbWVcclxuICAgICAqIEBwYXJhbSBwYXNzd29yZFxyXG4gICAgICogQHBhcmFtIGhlYWRlcnMgT3B0aW9uYWwgYWRkaXRpb25hbCBodHRwLWhlYWRlcnMuXHJcbiAgICAgKi9cclxuICAgIGZldGNoVG9rZW5Vc2luZ1Bhc3N3b3JkRmxvd0FuZExvYWRVc2VyUHJvZmlsZSh1c2VyTmFtZTogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nLCBoZWFkZXJzPzogSHR0cEhlYWRlcnMpOiBQcm9taXNlPFVzZXJJbmZvPjtcclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgdGhlIHVzZXIgcHJvZmlsZSBieSBhY2Nlc3NpbmcgdGhlIHVzZXIgaW5mbyBlbmRwb2ludCBkZWZpbmVkIGJ5IE9wZW5JZCBDb25uZWN0LlxyXG4gICAgICpcclxuICAgICAqIFdoZW4gdXNpbmcgdGhpcyB3aXRoIE9BdXRoMiBwYXNzd29yZCBmbG93LCBtYWtlIHN1cmUgdGhhdCB0aGUgcHJvcGVydHkgb2lkYyBpcyBzZXQgdG8gZmFsc2UuXHJcbiAgICAgKiBPdGhlcndpc2Ugc3RyaWN0ZXIgdmFsaWRhdGlvbnMgdGFrZSBwbGFjZSB0aGF0IG1ha2UgdGhpcyBvcGVyYXRpb24gZmFpbC5cclxuICAgICAqL1xyXG4gICAgbG9hZFVzZXJQcm9maWxlKCk6IFByb21pc2U8VXNlckluZm8+O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VzIHBhc3N3b3JkIGZsb3cgdG8gZXhjaGFuZ2UgdXNlck5hbWUgYW5kIHBhc3N3b3JkIGZvciBhbiBhY2Nlc3NfdG9rZW4uXHJcbiAgICAgKiBAcGFyYW0gdXNlck5hbWVcclxuICAgICAqIEBwYXJhbSBwYXNzd29yZFxyXG4gICAgICogQHBhcmFtIGhlYWRlcnMgT3B0aW9uYWwgYWRkaXRpb25hbCBodHRwLWhlYWRlcnMuXHJcbiAgICAgKi9cclxuICAgIGZldGNoVG9rZW5Vc2luZ1Bhc3N3b3JkRmxvdyh1c2VyTmFtZTogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nLCBoZWFkZXJzPzogSHR0cEhlYWRlcnMpOiBQcm9taXNlPFRva2VuUmVzcG9uc2U+O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZyZXNoZXMgdGhlIHRva2VuIHVzaW5nIGEgcmVmcmVzaF90b2tlbi5cclxuICAgICAqIFRoaXMgZG9lcyBub3Qgd29yayBmb3IgaW1wbGljaXQgZmxvdywgYi9jXHJcbiAgICAgKiB0aGVyZSBpcyBubyByZWZyZXNoX3Rva2VuIGluIHRoaXMgZmxvdy5cclxuICAgICAqIEEgc29sdXRpb24gZm9yIHRoaXMgaXMgcHJvdmlkZWQgYnkgdGhlXHJcbiAgICAgKiBtZXRob2Qgc2lsZW50UmVmcmVzaC5cclxuICAgICAqL1xyXG4gICAgcmVmcmVzaFRva2VuKCk6IFByb21pc2U8VG9rZW5SZXNwb25zZT47XHJcbiAgICBwcm90ZWN0ZWQgcmVtb3ZlU2lsZW50UmVmcmVzaEV2ZW50TGlzdGVuZXIoKTogdm9pZDtcclxuICAgIHByb3RlY3RlZCBzZXR1cFNpbGVudFJlZnJlc2hFdmVudExpc3RlbmVyKCk6IHZvaWQ7XHJcbiAgICAvKipcclxuICAgICAqIFBlcmZvcm1zIGEgc2lsZW50IHJlZnJlc2ggZm9yIGltcGxpY2l0IGZsb3cuXHJcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZ2V0IG5ldyB0b2tlbnMgd2hlbi9iZWZvcmVcclxuICAgICAqIHRoZSBleGlzdGluZyB0b2tlbnMgZXhwaXJlLlxyXG4gICAgICovXHJcbiAgICBzaWxlbnRSZWZyZXNoKHBhcmFtcz86IG9iamVjdCwgbm9Qcm9tcHQ/OiBib29sZWFuKTogUHJvbWlzZTxPQXV0aEV2ZW50PjtcclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgZXhpc3RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cclxuICAgICAqIHtAbGluayBPQXV0aFNlcnZpY2UjaW5pdExvZ2luRmxvd0luUG9wdXB9IGhhbmRsZXMgYm90aCBjb2RlXHJcbiAgICAgKiBhbmQgaW1wbGljaXQgZmxvd3MuXHJcbiAgICAgKi9cclxuICAgIGluaXRJbXBsaWNpdEZsb3dJblBvcHVwKG9wdGlvbnM/OiB7XHJcbiAgICAgICAgaGVpZ2h0PzogbnVtYmVyO1xyXG4gICAgICAgIHdpZHRoPzogbnVtYmVyO1xyXG4gICAgfSk6IFByb21pc2U8e30+O1xyXG4gICAgaW5pdExvZ2luRmxvd0luUG9wdXAob3B0aW9ucz86IHtcclxuICAgICAgICBoZWlnaHQ/OiBudW1iZXI7XHJcbiAgICAgICAgd2lkdGg/OiBudW1iZXI7XHJcbiAgICB9KTogUHJvbWlzZTx7fT47XHJcbiAgICBwcm90ZWN0ZWQgY2FsY3VsYXRlUG9wdXBGZWF0dXJlcyhvcHRpb25zOiB7XHJcbiAgICAgICAgaGVpZ2h0PzogbnVtYmVyO1xyXG4gICAgICAgIHdpZHRoPzogbnVtYmVyO1xyXG4gICAgfSk6IHN0cmluZztcclxuICAgIHByb3RlY3RlZCBwcm9jZXNzTWVzc2FnZUV2ZW50TWVzc2FnZShlOiBNZXNzYWdlRXZlbnQpOiBzdHJpbmc7XHJcbiAgICBwcm90ZWN0ZWQgY2FuUGVyZm9ybVNlc3Npb25DaGVjaygpOiBib29sZWFuO1xyXG4gICAgcHJvdGVjdGVkIHNldHVwU2Vzc2lvbkNoZWNrRXZlbnRMaXN0ZW5lcigpOiB2b2lkO1xyXG4gICAgcHJvdGVjdGVkIGhhbmRsZVNlc3Npb25VbmNoYW5nZWQoKTogdm9pZDtcclxuICAgIHByb3RlY3RlZCBoYW5kbGVTZXNzaW9uQ2hhbmdlKCk6IHZvaWQ7XHJcbiAgICBwcm90ZWN0ZWQgd2FpdEZvclNpbGVudFJlZnJlc2hBZnRlclNlc3Npb25DaGFuZ2UoKTogdm9pZDtcclxuICAgIHByb3RlY3RlZCBoYW5kbGVTZXNzaW9uRXJyb3IoKTogdm9pZDtcclxuICAgIHByb3RlY3RlZCByZW1vdmVTZXNzaW9uQ2hlY2tFdmVudExpc3RlbmVyKCk6IHZvaWQ7XHJcbiAgICBwcm90ZWN0ZWQgaW5pdFNlc3Npb25DaGVjaygpOiB2b2lkO1xyXG4gICAgcHJvdGVjdGVkIHN0YXJ0U2Vzc2lvbkNoZWNrVGltZXIoKTogdm9pZDtcclxuICAgIHByb3RlY3RlZCBzdG9wU2Vzc2lvbkNoZWNrVGltZXIoKTogdm9pZDtcclxuICAgIHByb3RlY3RlZCBjaGVja1Nlc3Npb24oKTogdm9pZDtcclxuICAgIHByb3RlY3RlZCBjcmVhdGVMb2dpblVybChzdGF0ZT86IHN0cmluZywgbG9naW5IaW50Pzogc3RyaW5nLCBjdXN0b21SZWRpcmVjdFVyaT86IHN0cmluZywgbm9Qcm9tcHQ/OiBib29sZWFuLCBwYXJhbXM/OiBvYmplY3QpOiBQcm9taXNlPHN0cmluZz47XHJcbiAgICBpbml0SW1wbGljaXRGbG93SW50ZXJuYWwoYWRkaXRpb25hbFN0YXRlPzogc3RyaW5nLCBwYXJhbXM/OiBzdHJpbmcgfCBvYmplY3QpOiB2b2lkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgdGhlIGltcGxpY2l0IGZsb3cgYW5kIHJlZGlyZWN0cyB0byB1c2VyIHRvXHJcbiAgICAgKiB0aGUgYXV0aCBzZXJ2ZXJzJyBsb2dpbiB1cmwuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxTdGF0ZSBPcHRpb25hbCBzdGF0ZSB0aGF0IGlzIHBhc3NlZCBhcm91bmQuXHJcbiAgICAgKiAgWW91J2xsIGZpbmQgdGhpcyBzdGF0ZSBpbiB0aGUgcHJvcGVydHkgYHN0YXRlYCBhZnRlciBgdHJ5TG9naW5gIGxvZ2dlZCBpbiB0aGUgdXNlci5cclxuICAgICAqIEBwYXJhbSBwYXJhbXMgSGFzaCB3aXRoIGFkZGl0aW9uYWwgcGFyYW1ldGVyLiBJZiBpdCBpcyBhIHN0cmluZywgaXQgaXMgdXNlZCBmb3IgdGhlXHJcbiAgICAgKiAgICAgICAgICAgICAgIHBhcmFtZXRlciBsb2dpbkhpbnQgKGZvciB0aGUgc2FrZSBvZiBjb21wYXRpYmlsaXR5IHdpdGggZm9ybWVyIHZlcnNpb25zKVxyXG4gICAgICovXHJcbiAgICBpbml0SW1wbGljaXRGbG93KGFkZGl0aW9uYWxTdGF0ZT86IHN0cmluZywgcGFyYW1zPzogc3RyaW5nIHwgb2JqZWN0KTogdm9pZDtcclxuICAgIC8qKlxyXG4gICAgICogUmVzZXQgY3VycmVudCBpbXBsaWNpdCBmbG93XHJcbiAgICAgKlxyXG4gICAgICogQGRlc2NyaXB0aW9uIFRoaXMgbWV0aG9kIGFsbG93cyByZXNldHRpbmcgdGhlIGN1cnJlbnQgaW1wbGljdCBmbG93IGluIG9yZGVyIHRvIGJlIGluaXRpYWxpemVkIGFnYWluLlxyXG4gICAgICovXHJcbiAgICByZXNldEltcGxpY2l0RmxvdygpOiB2b2lkO1xyXG4gICAgcHJvdGVjdGVkIGNhbGxPblRva2VuUmVjZWl2ZWRJZkV4aXN0cyhvcHRpb25zOiBMb2dpbk9wdGlvbnMpOiB2b2lkO1xyXG4gICAgcHJvdGVjdGVkIHN0b3JlQWNjZXNzVG9rZW5SZXNwb25zZShhY2Nlc3NUb2tlbjogc3RyaW5nLCByZWZyZXNoVG9rZW46IHN0cmluZywgZXhwaXJlc0luOiBudW1iZXIsIGdyYW50ZWRTY29wZXM6IFN0cmluZyk6IHZvaWQ7XHJcbiAgICAvKipcclxuICAgICAqIERlbGVnYXRlcyB0byB0cnlMb2dpbkltcGxpY2l0RmxvdyBmb3IgdGhlIHNha2Ugb2YgY29tcGV0YWJpbGl0eVxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uYWwgb3B0aW9ucy5cclxuICAgICAqL1xyXG4gICAgdHJ5TG9naW4ob3B0aW9ucz86IExvZ2luT3B0aW9ucyk6IFByb21pc2U8Ym9vbGVhbj47XHJcbiAgICBwcml2YXRlIHBhcnNlUXVlcnlTdHJpbmc7XHJcbiAgICB0cnlMb2dpbkNvZGVGbG93KG9wdGlvbnM/OiBMb2dpbk9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+O1xyXG4gICAgLyoqXHJcbiAgICAqIFJldHJpZXZlIHRoZSByZXR1cm5lZCBhdXRoIGNvZGUgZnJvbSB0aGUgcmVkaXJlY3QgdXJpIHRoYXQgaGFzIGJlZW4gY2FsbGVkLlxyXG4gICAgKiBJZiByZXF1aXJlZCBhbHNvIGNoZWNrIGhhc2gsIGFzIHdlIGNvdWxkIHVzZSBoYXNoIGxvY2F0aW9uIHN0cmF0ZWd5LlxyXG4gICAgKi9cclxuICAgIHByaXZhdGUgZ2V0Q29kZVBhcnRzRnJvbVVybDtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRva2VuIHVzaW5nIGFuIGludGVybWVkaWF0ZSBjb2RlLiBXb3JrcyBmb3IgdGhlIEF1dGhvcml6YXRpb24gQ29kZSBmbG93LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGdldFRva2VuRnJvbUNvZGU7XHJcbiAgICBwcml2YXRlIGZldGNoQW5kUHJvY2Vzc1Rva2VuO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGVyZSBhcmUgdG9rZW5zIGluIHRoZSBoYXNoIGZyYWdtZW50XHJcbiAgICAgKiBhcyBhIHJlc3VsdCBvZiB0aGUgaW1wbGljaXQgZmxvdy4gVGhlc2UgdG9rZW5zIGFyZVxyXG4gICAgICogcGFyc2VkLCB2YWxpZGF0ZWQgYW5kIHVzZWQgdG8gc2lnbiB0aGUgdXNlciBpbiB0byB0aGVcclxuICAgICAqIGN1cnJlbnQgY2xpZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbmFsIG9wdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIHRyeUxvZ2luSW1wbGljaXRGbG93KG9wdGlvbnM/OiBMb2dpbk9wdGlvbnMpOiBQcm9taXNlPGJvb2xlYW4+O1xyXG4gICAgcHJpdmF0ZSBwYXJzZVN0YXRlO1xyXG4gICAgcHJvdGVjdGVkIHZhbGlkYXRlTm9uY2Uobm9uY2VJblN0YXRlOiBzdHJpbmcpOiBib29sZWFuO1xyXG4gICAgcHJvdGVjdGVkIHN0b3JlSWRUb2tlbihpZFRva2VuOiBQYXJzZWRJZFRva2VuKTogdm9pZDtcclxuICAgIHByb3RlY3RlZCBzdG9yZVNlc3Npb25TdGF0ZShzZXNzaW9uU3RhdGU6IHN0cmluZyk6IHZvaWQ7XHJcbiAgICBwcm90ZWN0ZWQgZ2V0U2Vzc2lvblN0YXRlKCk6IHN0cmluZztcclxuICAgIHByb3RlY3RlZCBoYW5kbGVMb2dpbkVycm9yKG9wdGlvbnM6IExvZ2luT3B0aW9ucywgcGFydHM6IG9iamVjdCk6IHZvaWQ7XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgcHJvY2Vzc0lkVG9rZW4oaWRUb2tlbjogc3RyaW5nLCBhY2Nlc3NUb2tlbjogc3RyaW5nLCBza2lwTm9uY2VDaGVjaz86IGJvb2xlYW4pOiBQcm9taXNlPFBhcnNlZElkVG9rZW4+O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSByZWNlaXZlZCBjbGFpbXMgYWJvdXQgdGhlIHVzZXIuXHJcbiAgICAgKi9cclxuICAgIGdldElkZW50aXR5Q2xhaW1zKCk6IG9iamVjdDtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZ3JhbnRlZCBzY29wZXMgZnJvbSB0aGUgc2VydmVyLlxyXG4gICAgICovXHJcbiAgICBnZXRHcmFudGVkU2NvcGVzKCk6IG9iamVjdDtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBpZF90b2tlbi5cclxuICAgICAqL1xyXG4gICAgZ2V0SWRUb2tlbigpOiBzdHJpbmc7XHJcbiAgICBwcm90ZWN0ZWQgcGFkQmFzZTY0KGJhc2U2NGRhdGE6IGFueSk6IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBhY2Nlc3NfdG9rZW4uXHJcbiAgICAgKi9cclxuICAgIGdldEFjY2Vzc1Rva2VuKCk6IHN0cmluZztcclxuICAgIGdldFJlZnJlc2hUb2tlbigpOiBzdHJpbmc7XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGV4cGlyYXRpb24gZGF0ZSBvZiB0aGUgYWNjZXNzX3Rva2VuXHJcbiAgICAgKiBhcyBtaWxsaXNlY29uZHMgc2luY2UgMTk3MC5cclxuICAgICAqL1xyXG4gICAgZ2V0QWNjZXNzVG9rZW5FeHBpcmF0aW9uKCk6IG51bWJlcjtcclxuICAgIHByb3RlY3RlZCBnZXRBY2Nlc3NUb2tlblN0b3JlZEF0KCk6IG51bWJlcjtcclxuICAgIHByb3RlY3RlZCBnZXRJZFRva2VuU3RvcmVkQXQoKTogbnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBleHBpcmF0aW9uIGRhdGUgb2YgdGhlIGlkX3Rva2VuXHJcbiAgICAgKiBhcyBtaWxsaXNlY29uZHMgc2luY2UgMTk3MC5cclxuICAgICAqL1xyXG4gICAgZ2V0SWRUb2tlbkV4cGlyYXRpb24oKTogbnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja2VzLCB3aGV0aGVyIHRoZXJlIGlzIGEgdmFsaWQgYWNjZXNzX3Rva2VuLlxyXG4gICAgICovXHJcbiAgICBoYXNWYWxpZEFjY2Vzc1Rva2VuKCk6IGJvb2xlYW47XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZXJlIGlzIGEgdmFsaWQgaWRfdG9rZW4uXHJcbiAgICAgKi9cclxuICAgIGhhc1ZhbGlkSWRUb2tlbigpOiBib29sZWFuO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBhdXRoLWhlYWRlciB0aGF0IGNhbiBiZSB1c2VkXHJcbiAgICAgKiB0byB0cmFuc21pdCB0aGUgYWNjZXNzX3Rva2VuIHRvIGEgc2VydmljZVxyXG4gICAgICovXHJcbiAgICBhdXRob3JpemF0aW9uSGVhZGVyKCk6IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhbGwgdG9rZW5zIGFuZCBsb2dzIHRoZSB1c2VyIG91dC5cclxuICAgICAqIElmIGEgbG9nb3V0IHVybCBpcyBjb25maWd1cmVkLCB0aGUgdXNlciBpc1xyXG4gICAgICogcmVkaXJlY3RlZCB0byBpdC5cclxuICAgICAqIEBwYXJhbSBub1JlZGlyZWN0VG9Mb2dvdXRVcmxcclxuICAgICAqL1xyXG4gICAgbG9nT3V0KG5vUmVkaXJlY3RUb0xvZ291dFVybD86IGJvb2xlYW4pOiB2b2lkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZUFuZFNhdmVOb25jZSgpOiBQcm9taXNlPHN0cmluZz47XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcclxuICAgIHByb3RlY3RlZCBjcmVhdGVOb25jZSgpOiBQcm9taXNlPHN0cmluZz47XHJcbiAgICBwcm90ZWN0ZWQgY2hlY2tBdEhhc2gocGFyYW1zOiBWYWxpZGF0aW9uUGFyYW1zKTogUHJvbWlzZTxib29sZWFuPjtcclxuICAgIHByb3RlY3RlZCBjaGVja1NpZ25hdHVyZShwYXJhbXM6IFZhbGlkYXRpb25QYXJhbXMpOiBQcm9taXNlPGFueT47XHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0IHRoZSBpbXBsaWNpdCBmbG93IG9yIHRoZSBjb2RlIGZsb3csXHJcbiAgICAgKiBkZXBlbmRpbmcgb24geW91ciBjb25maWd1cmF0aW9uLlxyXG4gICAgICovXHJcbiAgICBpbml0TG9naW5GbG93KGFkZGl0aW9uYWxTdGF0ZT86IHN0cmluZywgcGFyYW1zPzoge30pOiB2b2lkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgdGhlIGF1dGhvcml6YXRpb24gY29kZSBmbG93IGFuZCByZWRpcmVjdHMgdG8gdXNlciB0b1xyXG4gICAgICogdGhlIGF1dGggc2VydmVycyBsb2dpbiB1cmwuXHJcbiAgICAgKi9cclxuICAgIGluaXRDb2RlRmxvdyhhZGRpdGlvbmFsU3RhdGU/OiBzdHJpbmcsIHBhcmFtcz86IHt9KTogdm9pZDtcclxuICAgIHByaXZhdGUgaW5pdENvZGVGbG93SW50ZXJuYWw7XHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlQ2hhbGxhbmdlVmVyaWZpZXJQYWlyRm9yUEtDRSgpOiBQcm9taXNlPFtzdHJpbmcsIHN0cmluZ10+O1xyXG59XHJcbiJdfQ==